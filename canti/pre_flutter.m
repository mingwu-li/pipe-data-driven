%% Finding a 2D SSM for a cantilerved pipe conveying fluid: pre-flutter
% This is an example of how to reconstruct a slow 2D SSM of a mechanical system 
% using synthetic measurements of a scalar quantity. In this example, we measure 
% the endpoint displacement of a cantilerved geometrically nonlinear pipe 
% conveying fluid. [1]
% 
% [1] Paidoussis, M. P. (1998). _Fluid-structure interactions: slender structures 
% and axial flow_ (Vol. 1). Academic press. 
%
% Here we take flow speed to be 0.1 to study the dynamics of the pipe in
% the pre-flutter regime.

clearvars
close all
%% Example setup
nmodes = 4;
fcload = 1;
flowspeed = 0.1;
miu = 0;
Gamma=0;
alpha=0.001;
beta=0.2;
[M, C, K, fnl, fext] = build_model(nmodes,flowspeed,beta,miu,Gamma,alpha,'clamped-free','nonlinear_damp');
n = size(M,1);    % mechanical dofs (axial def, transverse def, angle)
[F, lambda] = functionFromTensors(M, C, K, fnl);
lambda = sort(lambda);
%% Generation of Synthetic Data
% Having set up the dynamics of the problem, we now move on to generate synthetic 
% data, which will be used to fit a parametrisation of the manifold. We will divide 
% the data into a training set, for model fitting, and a test set, for validation. 
% In this case we will use one trajectory as the training set and another one 
% as the test set.

loads = -[1.0 1.5]; % we apply a static load at the free end of the pipe
nTraj = size(loads, 2);
indTest = 1;
indTrain = 2;
%% 
% We now set the initial conditions for the trajectories. Our test set trajectory 
% is initialized by applying a point load at the free end of the pipe. The load 
% is removed at the start of the simulation. For the training trajectory, we use 
% a different point load magnitude. We expect the trajectories to eventually converge 
% onto a slow 2D manifold, which will be identified and used to reduce the system 
% dynamics.

phiend = zeros(n,1);
lamda  = zeros(n,1);
lamda(1)=1.8751040687119611664453082410782141625701117335311;
lamda(2)=4.6940911329741745764363917780198120493898967375458;
lamda(3)=7.8547574382376125648610085827645704578485419292300;
lamda(4)=10.995540734875466990667349107854702939612972774652;
lamda(5)=14.137168391046470580917046812551772068603076792975;
lamda(6)=17.278759532088236333543928414375822085934519635550;
lamda(7)=20.420352251041250994415811947947837046137288894544;
lamda(8)=23.561944901806443501520253240198075517031265990051;
for k=1:n
   x    = 1;
   phin = cos(lamda(k)*x)-cosh(lamda(k)*x)-(cos(lamda(k))+cosh(lamda(k)))/(sin(lamda(k))+sinh(lamda(k)))*...
        (sin(lamda(k)*x)-sinh(lamda(k)*x));%clamped-free
   phiend(k) = phin;
end

loadvector = loads.*phiend;
IC = getStaticResponse(K, M, F, loadvector);
%% 
% The data is generated by time-integration of the right-hand side of the system. 
% In this case we are observing the midpoint displacement, so the |observable| 
% function is selected to save only the transverse displacement of the center 
% element. We also make sure that the data is sampled with a sufficiently high 
% frequency.
% 
% To save execution time and avoid rerunning the simulation, |newMeasurement| 
% can be set to |false|.

newMeasurement = true;
observable = @(x) phiend'*x(1:n,:);
slowTimeScale = 2*pi/abs(lambda(1));
numberPeriods = 25; numberPointsPerPeriod = 100;
if newMeasurement
    endTime = numberPeriods*slowTimeScale;
    nSamp = numberPeriods*numberPointsPerPeriod+1;
    dt = endTime/(nSamp-1);
    xData = integrateTrajectories(F, endTime, IC, nSamp, observable);
    DataInfo = struct('nmodes', nmodes, 'loadvector', loadvector);
    save('dataVKDecay_pre.mat', 'DataInfo', 'xData', 'dt', 'endTime', 'nSamp')
else
    load dataVKDecay_pre.mat
    if nmodes ~= DataInfo.nmodes
       error('The loaded data comes from a model with a different number of elements.') 
    end
end
%% Delay embedding
% Now we arrange the scalar measurements in an observable space of dimension 
% at least $2m+1$, with $m$ the dimension of the manifold. This guarantees that 
% the manifold from the full state space can be embedded in the observable space. 
% The dimensionality of the observable space can be further expanded with the 
% parameter |overEmbed| to facilitate recognition of the manifold from data.
% 
% We form a multi-dimensional observable by stacking $d$ subsequent scalar measurements 
% $x$ in a vector $y$, and we will later use the trajectories in this augmented 
% space for the manifold fitting.
% 
% $$\left[\begin{array}{c}y_{1} \\ \vdots \\ y_{i+1} \\ \vdots \\ y_{d+1}\end{array} 
% \right] = \left[\begin{array}{c}x(t^k) \\ \vdots \\ x(t^k+i\Delta t) \\ \vdots 
% \\ x(t^k+d\Delta t)\end{array} \right]$$
% 
% The total number of embedded coordinates is $2m+1 + \texttt{overEmbed}$.

SSMDim = 2;
overEmbed = 0;
yData = coordinatesEmbedding(xData, SSMDim, 'OverEmbedding', overEmbed);
%% Data analysis
% We need to make sure that the data that we use to identify the slow manifold 
% lies close to it. We can do this by plotting a spectrogram of the beam tip displacement. 
% In general, there may be many vibratory modes present at first, but the faster 
% ones quickly die out.

showSpectrogram(yData(indTrain,:), 1);
ylim([0,abs(lambda(1))/2/pi*10])
%% 
% We plot the tip displacement over time for closer inspection. 

customFigure();
plot(xData{1,1}, xData{1,2}, xData{2,1}, xData{2,2}, ':');
xlabel('$t \, [$s$]$','Interpreter','latex'); 
ylabel('$u \, [$m$]$','Interpreter','latex'); 
legend({'Trajectory 1', 'Trajectory 2'})
title('Generated data')
%% 
% Next, we use the information from the spectrogram and plot to remove the first 
% part of the training data. After the first few oscillations have passed, there 
% is one dominant mode left in the frequency spectrum. In this case, faster modes 
% die out very quickly, so we can use almost all of the data. We must however 
% remove the first transient to fulfill the assumption that trajectories lie close 
% to the SSM. We keep only the time interval |sliceInt|.

sliceInt = [5*slowTimeScale, endTime];
yDataTrunc = sliceTrajectories(yData, sliceInt);
%% Datadriven manifold fitting
SSMOrder = 1; % we fit a flat SSM here
[IMInfo, SSMChart, SSMFunction] = IMGeometry(yDataTrunc(indTrain,:), SSMDim, SSMOrder);
%% Plot and validation
% Now that we have computed the eigenspace of the manifold, we pass to the reduced 
% coordinates $y$ by projecting all trajectories onto the eigenspace:
% 
% $\eta = V_e^\top y$.

etaData = projectTrajectories(IMInfo, yData);
etaDataTrunc = projectTrajectories(IMInfo, yDataTrunc);
%% 
% We plot the test and training set trajectories projected onto the plane. After 
% all initial transients die out, the trajectories seem to be confined to a slowly 
% decaying oscillating eigenmode. This is the data we will use to train our reduced 
% order model for the dynamics. In these coordinates, the initial transient that 
% we removed is visible as irregular high-frequency oscillations in the first 
% revolution.

plotReducedCoordinates(etaData);
legend({'Test set trajectory', 'Training set trajectory'})
%% 
% Furthermore, we draw the end tip component of the manifold shape along with 
% the truncated trajectory from the training set. 

plotSSMWithTrajectories(IMInfo, 1, yDataTrunc(indTrain,:))
view(-100,20); zlabel('$u \, [$m$]$','Interpreter','latex')
%% Reduced order model
ROMOrder = 5; % we fit an extended normal form at O(5)
RDInfo = IMDynamicsFlow(etaDataTrunc(indTrain,:), ...
    'R_PolyOrd', ROMOrder, 'style', 'normalform');
%% 
[yRec, etaRec, zRec] = advect(IMInfo, RDInfo, yDataTrunc);
%% Evaluation of reduced dynamics
normedTrajDist = computeTrajectoryErrors(yRec, yDataTrunc);
NMTE = mean(normedTrajDist(indTest)) % conjugacy error
%% 
% We plot the true test set trajectory in the reduced coordinates and compare 
% it to the prediction. 
plotReducedCoordinates(etaDataTrunc(indTest,:), etaRec(indTest,:))
legend({'Test set (truncated)', 'Prediction'})

plotReducedCoordinates(etaDataTrunc(indTrain,:), etaRec(indTrain,:))
legend({'Train set (truncated)', 'Prediction'})
%% 
% We also plot the measured and predicted tip displacement. The reduced model 
% seems to do well on previously unseen data, provided that it is close to the 
% 2D manifold.
plotTrajectories(yData(indTest,:), yRec(indTest,:), 'm', 'DisplayName', {'Test set', 'Prediction'})
ylabel('$u \, [$m$]$','Interpreter','latex')

plotTrajectories(yData(indTrain,:), yRec(indTrain,:), 'm', 'DisplayName', {'Train set', 'Prediction'})
ylabel('$u \, [$m$]$','Interpreter','latex')
%% 
% We compare the estimated eigenvalues of the continuous evolution function 
% to the ones computed from the linearized system. 
lambda = sort(lambda);
DSEigenvalues = lambda(1:SSMDim) % reference
reconstructedEigenvalues = sort(RDInfo.eigenvaluesLinPartFlow) % predicted
%% Backbone curves
% With the knowledge of the coefficients of the normal form, we extract backbone 
% curves for the instantaneous damping and frequency. In this delay-embedding 
% example, the reference physical amplitude is that of the first coordinate.

zData = transformTrajectories(RDInfo.inverseTransformation.map, etaData);
rhoCal = abs(zData{indTest(1),2}(1,1));
amplitudeFunction = @(x) x(1,:);
figure
BBCInfo = backboneCurves(IMInfo, RDInfo, amplitudeFunction, rhoCal);
subplot(121); ylabel('$u \, [$m$]$','Interpreter','latex')
subplot(122); ylabel('$u \, [$m$]$','Interpreter','latex')
%% Forced response curves
% FRC calibration
% We use our normal form dynamics to extract a forced response curve. To this 
% end, we need to define the forcing amplitude in the normal form. We do this 
% by passing to |calibrateFRC| a frequency and a point $y_\mathrm{cal}$ in the 
% observable space. At the defined frequency, the calibrated FRC will reach the 
% amplitude of this point. 
% 
% The vector $y_\mathrm{cal}$ lies in a delay embedded space, and can be computed 
% either from a delay embedded time-varying response signal, or from a scalar 
% maximal response that is artifically delay embedded. Here, |integrationBasedCalibration| 
% allows for simulation of the forced system, where $y_\mathrm{cal}$ is computed 
% from the stable response signal. Alternatively, a scalar value $u_\mathrm{cal}$ 
% can be mapped to the observable space via a cosine function oscillating at the 
% forcing frequency.

embedDim = size(yData{1,2}, 1);
omegaSpan = abs(imag(lambda(1)))*[0.95 1.15];
outdof = 1:n;
fFull  = [0.01 0.02 0.035]*0.3;
Omega = zeros(numel(fFull),1);
yCal  = zeros(2*SSMDim+1+overEmbed,numel(fFull));
for k=1:numel(fFull)
    Omega(k) = abs(imag(lambda(1)))*1.05;
    uICLinGuess = full(Omega(k)^2*fFull(k)*((-Omega(k)^2*M+K)\fext));
    FForced = @(t,x,w) F(t,x) + [zeros(n,1); Omega(k)^2*fFull(k)*(M\fext)*cos(w*t)];
    opts = odeset('RelTol', 1e-4); 
    [t_sim,x_sim] = ode15s(@(t,x) FForced(t,x,Omega(k)),[0 100*2*pi/Omega(k)], [uICLinGuess; zeros(n,1)],opts);
    customFigure(); plot(t_sim,x_sim(:,outdof)*phiend,'Linewidth',1); drawnow;
    [t_sim,x_sim] = ode15s(@(t,x) FForced(t,x,Omega(k)),t_sim(end)+[0 1*2*pi/Omega(k)], x_sim(end,:)',opts);
    plot(t_sim,x_sim(:,outdof)*phiend,'Linewidth',1); drawnow;
    uCal = max(abs(x_sim(:,outdof)*phiend));
    yCal(:,k) = uCal*cos(Omega(k)*dt*((1:embedDim)-ceil(0.5*embedDim))).';
end

% forcing levels in the normal form space
fRed = calibrateFRC(IMInfo, RDInfo, yCal, Omega);
fRed = fRed./Omega.^2; % due to base excitation
% we expect a proportional relation between fFull and fRed
figure; plot(fFull,fRed,'ro')
p = polyfit(fFull,fRed,1)
kapa = fRed./fFull';
kapa = kapa(1)

%% Data-driven FRC computation
% We now compute the FRC directly from the reduced dynamics model.
fFull  = [0.01 0.02 0.035]*0.3; 
FRCs = cell(numel(fFull),1);
for k=1:numel(fFull)
    runidk = ['prefreq',num2str(k)];
    FRCs{k} = cont_po_FRC(IMInfo, RDInfo,kapa, fFull(k), omegaSpan, runidk, amplitudeFunction, true, 0.1);
end

%% FRC via collocation method for validation
% we use the collocation method implemented in po-toolbox of coco to
% extract FRCs of the full system for the purpose of validation
newcoll = true;
if newcoll
    figure;
    DS = DynamicalSystem();
    set(DS,'M',M,'C',C,'K',K,'fnl',fnl);
    set(DS.Options,'Emax',5,'Nmax',10,'notation','multiindex');
    set(DS.Options,'BaseExcitation',true);
    [V,D,W] = DS.linear_spectral_analysis();
    DS.Omega = 0.95*abs(imag(lambda(1)));
    nCycles = 10;
    outdof = 1; % first modal coordinate
    kappas = [-1; 1];
    freqRange = [0.95 1.15]*abs(imag(lambda(1)));
    for k=1:numel(fFull)
        coeffs = [fext fext]/2;
        DS.add_forcing(coeffs, kappas, fFull(k));
        coll = cocoWrapper(DS, nCycles, outdof);
        set(coll.Options, 'dir_name', ['force_',num2str(k)],...
            'h_max', 10, 'NAdapt', 2, 'PtMX', 200, 'NSV',2);        
        if k==1
        set(coll.Options,'h_max', 10, 'NAdapt', 2, 'PtMX', 200, 'NSV',2);
        else
        end
        coll.initialGuess = 'linear';
        coll.extract_FRC(freqRange);
    end
    % post-processing: from modal coordinates to physical coordinates
    collsol = cell(numel(fFull),1);
    for k=1:numel(fFull)
        runid = ['force_',num2str(k),'.FRC'];
        bd = coco_bd_read(runid);
        EPlab = coco_bd_labs(bd,'EP');
        EPlab = max(EPlab);
        st = false(EPlab,1);
        omegas = zeros(EPlab,1);
        yends  = zeros(EPlab,1);
        for j=1:EPlab
            solj = po_read_solution(runid,j);
            yend = solj.xbp(:,1:n)*phiend;
            omegas(j) = solj.p(1);
            yends(j)  = norm(yend,'inf');
            st(j) = all(abs(solj.po_test.la)<1);
        end
        sol = struct();
        sol.omega = omegas; sol.yend = yends; sol.st = st;
        collsol{k} = sol;
    end
    save('dataVKcoll_pre.mat','collsol')
else
    load('dataVKcoll_pre.mat', 'collsol')
end

%% plot results in the same figure (FRCs and backbone curve)
figure; 
colors = colororder;
plot(BBCInfo.frequency, BBCInfo.amplitude,'Color',colors(1,:),'Linewidth',2,'DisplayName', 'SSM-Backbone')
hold on; legend show
thm = struct();
thm.SN = {'LineStyle', 'none', 'LineWidth', 2, ...
  'Color', 'cyan', 'Marker', 'o', 'MarkerSize', 8, 'MarkerEdgeColor', ...
  'cyan', 'MarkerFaceColor', 'white'};
thm.HB = {'LineStyle', 'none', 'LineWidth', 2, ...
  'Color', 'black', 'Marker', 's', 'MarkerSize', 8, 'MarkerEdgeColor', ...
  'black', 'MarkerFaceColor', 'white'};
color = {'r','k','m','b','g'};
% color
ST = cell(2,1);
ST{1} = {'b--','LineWidth',1.5}; % unstable
ST{2} = {'b-','LineWidth',1.5};  % stable
legs = 'SSM-FRC-unstable';
legu = 'SSM-FRC-stable';
ax1 = gca;
for k=[1 2 3]
    FRC = FRCs{k};
    SNidx = FRC.SNidx;
    HBidx = FRC.HBidx;
    FRC.st = double(FRC.st);
    FRC.st(HBidx) = nan;
    FRC.st(SNidx) = nan;
    hold(ax1,'on');
    if k==2
        plot_stab_lines(FRC.om,FRC.Aout(:,1),FRC.st,ST,legs,legu);
    else
        plot_stab_lines(FRC.om,FRC.Aout(:,1),FRC.st,ST);
    end
    SNfig = plot(FRC.om(SNidx),FRC.Aout(SNidx,1),thm.SN{:});
    set(get(get(SNfig,'Annotation'),'LegendInformation'),...
    'IconDisplayStyle','off');
    HBfig = plot(FRC.om(HBidx),FRC.Aout(HBidx,1),thm.HB{:});
    set(get(get(HBfig,'Annotation'),'LegendInformation'),...
    'IconDisplayStyle','off');   
    xlabel('$\Omega$','Interpreter','latex'); 
    ylabel('$||u_1||_{\infty}$','Interpreter','latex'); 
    set(gca,'FontSize',14);
    grid on; axis tight; 
end

for k=[1 2 3]
    colk = collsol{k};
    h = plot(colk.omega(colk.st),colk.yend(colk.st),'ro','DisplayName','COCO-stable');
    g = plot(colk.omega(~colk.st),colk.yend(~colk.st),'ms','DisplayName','COCO-unstable');
    if k~=2
        h.Annotation.LegendInformation.IconDisplayStyle = 'off';
        if ~isempty(g)
        g.Annotation.LegendInformation.IconDisplayStyle = 'off';
        end
    end
end

xlim(omegaSpan); ylim([0 0.35])
xlabel('forcing frequency [rad/s]')
ylabel('displacement')
set(gca, 'FontSize', 12)
legend('location','NW')
legend boxoff
% % errorInfo = conjugacyErrorTrend(etaDataTrunc,indTrain,indTest,3:2:11);