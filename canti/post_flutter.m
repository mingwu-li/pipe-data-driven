%% Finding a 2D SSM for a cantilerved pipe conveying fluid: post-flutter
% This is an example of how to reconstruct a slow 2D SSM of a mechanical system 
% using synthetic measurements of a scalar quantity. In this example, we measure 
% the midpoint displacement of a simply supported geometrically nonlinear pipe 
% conveying fluid. [1]
% 
% [1] Paidoussis, M. P. (1998). _Fluid-structure interactions: slender structures 
% and axial flow_ (Vol. 1). Academic press. 
% 
% Here we take flow speed to be 6 to study the dynamics of the pipe in
% the pre-flutter regime.


clearvars; clear all;
close all
%% Example setup
nmodes = 4;
fcload = 1;
flowspeed = 6;
miu = 0;
Gamma=0;
alpha=0.001;
beta=0.2;
[M, C, K, fnl, fext] = build_model(nmodes,flowspeed,beta,miu,Gamma,alpha,'clamped-free','nonlinear_damp');
n = size(M,1);    % mechanical dofs (axial def, transverse def, angle)
[F, lambda] = functionFromTensors(M, C, K, fnl);
lambda = sort(lambda);
%% Generation of Synthetic Data
% Having set up the dynamics of the problem, we now move on to generate synthetic 
% data, which will be used to fit a parametrisation of the manifold. We will divide 
% the data into a training set, for model fitting, and a test set, for validation. 
% In this case we will use one trajectory as the training set and another one 
% as the test set.

loads = -[1.0 2]/10;
nTraj = size(loads, 2);
indTest = 1;
indTrain = 2;
%% 
% We now set the initial conditions for the trajectories. Our test set trajectory 
% is initialized by applying a point load at the free end of the pipe. The load 
% is removed at the start of the simulation. For the training trajectory, we use 
% a different point load magnitude. We expect the trajectories to eventually converge 
% onto a slow 2D manifold, which will be identified and used to reduce the system 
% dynamics.

phiend = zeros(n,1);
lamda  = zeros(n,1);
lamda(1)=1.8751040687119611664453082410782141625701117335311;
lamda(2)=4.6940911329741745764363917780198120493898967375458;
lamda(3)=7.8547574382376125648610085827645704578485419292300;
lamda(4)=10.995540734875466990667349107854702939612972774652;
lamda(5)=14.137168391046470580917046812551772068603076792975;
lamda(6)=17.278759532088236333543928414375822085934519635550;
lamda(7)=20.420352251041250994415811947947837046137288894544;
lamda(8)=23.561944901806443501520253240198075517031265990051;
for k=1:n
   x    = 1;
   phin = cos(lamda(k)*x)-cosh(lamda(k)*x)-(cos(lamda(k))+cosh(lamda(k)))/(sin(lamda(k))+sinh(lamda(k)))*...
        (sin(lamda(k)*x)-sinh(lamda(k)*x));%clamped-free
   phiend(k) = phin;
end

loadvector = loads.*phiend;
IC = getStaticResponse(K, M, F, loadvector);
%% 
% The data is generated by time-integration of the right-hand side of the system. 
% In this case we are observing the midpoint displacement, so the |observable| 
% function is selected to save only the transverse displacement of the center 
% element. We also make sure that the data is sampled with a sufficiently high 
% frequency.
% 
% To save execution time and avoid rerunning the simulation, |newMeasurement| 
% can be set to |false|.

newMeasurement = true;
observable = @(x) phiend'*x(1:n,:);
slowTimeScale = 2*pi/abs(lambda(1));
numberPeriods = 25; numberPointsPerPeriod = 100;
if newMeasurement
    endTime = numberPeriods*slowTimeScale;
    nSamp = numberPeriods*numberPointsPerPeriod+1;
    dt = endTime/(nSamp-1);
    xData = integrateTrajectories(F, endTime, IC, nSamp, observable);
    DataInfo = struct('nmodes', nmodes, 'loadvector', loadvector);
    save('dataVKDecay_post.mat', 'DataInfo', 'xData', 'dt', 'endTime', 'nSamp')
else
    load dataVKDecay_post.mat
    if nmodes ~= DataInfo.nmodes
       error('The loaded data comes from a model with a different number of elements.') 
    end
end
%% Delay embedding
% The total number of embedded coordinates is $2m+1 + \texttt{overEmbed}$.
SSMDim = 2;
overEmbed = 0;
yData = coordinatesEmbedding(xData, SSMDim, 'OverEmbedding', overEmbed);
%% Data analysis
% We need to make sure that the data that we use to identify the slow manifold 
% lies close to it. We can do this by plotting a spectrogram of the beam tip displacement. 
% In general, there may be many vibratory modes present at first, but the faster 
% ones quickly die out.

showSpectrogram(yData(indTrain,:), 1);
ylim([0,abs(lambda(1))/2/pi*10])
%% 
% We plot the tip displacement over time for closer inspection. 

customFigure();
plot(xData{1,1}, xData{1,2}, xData{2,1}, xData{2,2}, ':');
xlabel('$t \, [$s$]$','Interpreter','latex'); 
ylabel('$u \, [$m$]$','Interpreter','latex'); 
legend({'Trajectory 1', 'Trajectory 2'})
title('Generated data')
%% 
% Next, we use the information from the spectrogram and plot to remove the first 
% part of the training data. After the first few oscillations have passed, there 
% is one dominant mode left in the frequency spectrum. In this case, faster modes 
% die out very quickly, so we can use almost all of the data. We must however 
% remove the first transient to fulfill the assumption that trajectories lie close 
% to the SSM. We keep only the time interval |sliceInt|.

sliceInt = [3*slowTimeScale, endTime];
yDataTrunc = sliceTrajectories(yData, sliceInt);
%% Datadriven manifold fitting
SSMOrder = 1; % we fit a flat SSM here
[IMInfo, SSMChart, SSMFunction] = IMGeometry(yDataTrunc(indTrain,:), SSMDim, SSMOrder);
%% Plot and validation
% Now that we have computed the eigenspace of the manifold, we pass to the reduced 
% coordinates $y$ by projecting all trajectories onto the eigenspace:
% 
% $\eta = V_e^\top y$.
etaData = projectTrajectories(IMInfo, yData);
etaDataTrunc = projectTrajectories(IMInfo, yDataTrunc);
%% 
% We plot the test and training set trajectories projected onto the plane. After 
% all initial transients die out, the trajectories seem to be confined to a slowly 
% decaying oscillating eigenmode. This is the data we will use to train our reduced 
% order model for the dynamics. In these coordinates, the initial transient that 
% we removed is visible as irregular high-frequency oscillations in the first 
% revolution.

plotReducedCoordinates(etaData);
legend({'Test set trajectory', 'Training set trajectory'})
%% 
% Furthermore, we draw the end tip component of the manifold shape along with 
% the truncated trajectory from the training set. 
plotSSMWithTrajectories(IMInfo, 1, yDataTrunc(indTrain,:))
view(-100,20); zlabel('$u \, [$m$]$','Interpreter','latex')
%% Reduced order model
ROMOrder = 7; % we fit an extended normal form at O(7)
RDInfo = IMDynamicsFlow(etaDataTrunc(indTrain,:), ...
    'R_PolyOrd', ROMOrder, 'style', 'normalform');

[yRec, etaRec, zRec] = advect(IMInfo, RDInfo, yDataTrunc);
%% Evaluation of reduced dynamics
normedTrajDist = computeTrajectoryErrors(yRec, yDataTrunc);
NMTE = mean(normedTrajDist(indTest))
%% 
% We plot the true test set trajectory in the reduced coordinates and compare 
% it to the prediction. 
plotReducedCoordinates(etaDataTrunc(indTest,:), etaRec(indTest,:))
legend({'Test set (truncated)', 'Prediction'})

plotReducedCoordinates(etaDataTrunc(indTrain,:), etaRec(indTrain,:))
legend({'Train set (truncated)', 'Prediction'})
%% 
% We also plot the measured and predicted tip displacement. The reduced model 
% seems to do well on previously unseen data, provided that it is close to the 
% 2D manifold.
plotTrajectories(yData(indTest,:), yRec(indTest,:), 'm', 'DisplayName', {'Test set', 'Prediction'})
ylabel('$u \, [$m$]$','Interpreter','latex')

plotTrajectories(yData(indTrain,:), yRec(indTrain,:), 'm', 'DisplayName', {'Train set', 'Prediction'})
ylabel('$u \, [$m$]$','Interpreter','latex')
%% 
% We compare the estimated eigenvalues of the continuous evolution function 
% to the ones computed from the linearized system. 
lambda = sort(lambda);
DSEigenvalues = lambda(3:4) % reference
reconstructedEigenvalues = sort(RDInfo.eigenvaluesLinPartFlow) % fitted
%% Backbone curves
% With the knowledge of the coefficients of the normal form, we extract backbone 
% curves for the instantaneous damping and frequency. In this delay-embedding 
% example, the reference physical amplitude is that of the first coordinate.
zData = transformTrajectories(RDInfo.inverseTransformation.map, etaData);
rhoCal = 100*abs(zData{indTest(1),2}(1,1));
amplitudeFunction = @(x) x(1,:);
figure
BBCInfo = backboneCurves(IMInfo, RDInfo, amplitudeFunction, rhoCal);
subplot(121); ylabel('$u \, [$m$]$','Interpreter','latex')
subplot(122); ylabel('$u \, [$m$]$','Interpreter','latex')
%% Forced response curves
% FRC calibration
% We use our normal form dynamics to extract a forced response curve. To this 
% end, we need to define the forcing amplitude in the normal form. Depending on 
% the sampled frequency, the steady state of the pipe system can be periodic or 
% quasi-periodic orbits. 
%% 
% * In the case of periodic orbits, we do this by passing to |calibrateFRC| 
% a frequency and a point $y_\mathrm{cal}$ in the observable space. At the defined 
% frequency, the calibrated FRC will reach the amplitude of this point. The vector 
% $y_\mathrm{cal}$ lies in a delay embedded space, and can be computed either 
% from a delay embedded time-varying response signal, or from a scalar maximal 
% response that is artifically delay embedded. Here, |integrationBasedCalibration| 
% allows for simulation of the forced system, where $y_\mathrm{cal}$ is computed 
% from the stable response signal. Alternatively, a scalar value $u_\mathrm{cal}$ 
% can be mapped to the observable space via a cosine function oscillating at the 
% forcing frequency.
% * In the case of quasi-periodic orbits, we use period $2\pi/\Omega$ map to 
% extract the other frequency component of the torus. We then use parameter continuation 
% of limit cycles of the reduced dynamics to identify the forcing amplitude that 
% needs to be calibrated. 
%% 
% We note that the bandwidth of quasi-periodic orbits is much wider than that 
% of the periodic orbits. However, the first case is much easier relative to the 
% second case when it comes to the calibration of the force. Indeed, no parameter 
% continuation run is involved.
%% 
% Case 1: Quasi-periodic orbits
embedDim = size(yData{1,2}, 1);
omegaSpan = abs(imag(lambda(3)))*[0.95 1.15];
fFull = [1e-3 1.5e-3 1.7e-3 2e-3]; 
outdof = 1:n;
Omega = zeros(numel(fFull),1);
Ts = zeros(numel(fFull),1);
yCal  = zeros(2*SSMDim+1+overEmbed,numel(fFull));
for k=1:numel(fFull)
    Omega(k) = abs(imag(lambda(3)))*1.02; % 1.022
    uICLinGuess = full(Omega(k)^2*fFull(k)*((-Omega(k)^2*M+K)\fext));
    FForced = @(t,x,w) F(t,x) + [zeros(n,1); Omega(k)^2*fFull(k)*(M\fext)*cos(w*t)];
    opts = odeset('RelTol', 1e-4); 
    [t_sim,x_sim] = ode15s(@(t,x) FForced(t,x,Omega(k)),[0 200*2*pi/Omega(k)], [uICLinGuess; zeros(n,1)],opts);
    customFigure(); plot(t_sim,x_sim(:,outdof)*phiend,'Linewidth',1); drawnow;
    [t_sim,x_sim] = ode15s(@(t,x) FForced(t,x,Omega(k)),t_sim(end)+[0 1*2*pi/Omega(k)], x_sim(end,:)',opts);
    plot(t_sim,x_sim(:,outdof)*phiend,'Linewidth',1); drawnow;
    uCal = max(abs(x_sim(:,outdof)*phiend));
    yCal(:,k) = uCal*cos(Omega(k)*dt*((1:embedDim)-ceil(0.5*embedDim))).';
    customFigure();
    Tk = 2*pi/Omega(k);
    [t_sim,x_sim] = ode15s(@(t,x) FForced(t,x,Omega(k)),0:Tk:500*Tk, [uICLinGuess; zeros(n,1)],opts);
    yend = x_sim(:,outdof)*phiend;
    cidx = extrema_index(yend);
    Ts(k) = t_sim(cidx(end))-t_sim(cidx(end-2));
    plot(t_sim,yend,'r-'); drawnow
    customFigure();
    plot(x_sim(:,outdof)*phiend,x_sim(:,outdof+n)*phiend,'b.-'); drawnow
    figure;plot(t_sim,yend,'r-');hold on
    plot(t_sim(cidx),yend(cidx),'bo','LineWidth',2)
end
%%
fRed = calibrateQFRC(RDInfo,Ts,Omega);
figure; plot(fFull(2:end),fRed(2:end),'ro')
p = polyfit(fFull,fRed,1)
kapa = fRed./fFull'
kapa = kapa(4)


%% Data-driven FRC computation
% We now compute the FRC directly from the reduced dynamics model.
fFull  = [1e-3 2e-3 3e-3]; 
FRC1st = cell(numel(fFull),1);
for k=1:numel(fFull)
    runidk = ['postfreq_1st',num2str(k)];
    FRC1st{k} = cont_po_FRC(IMInfo, RDInfo,kapa, fFull(k), omegaSpan, runidk, amplitudeFunction, true, 0.1);
end
% to locate the isolated branches, we use the limit cycle to construct
% initial solutions of parameter continuation
coeffs = RDInfo.conjugateDynamics.coefficients;
alphas = real(coeffs);
omegas = imag(coeffs);
coeff_rho = zeros(ROMOrder+1,1);
coeff_rho(1:2:end) = alphas(end:-1:1);
rhos = roots(coeff_rho);
rho  = rhos(end);
os = 0;
for k=1:numel(alphas)
    os = os+omegas(k)*rho.^(2*k-2);
end
FRC2nd = cell(numel(fFull),1);
for k=1:numel(fFull)
    runidk = ['postfreq_2nd',num2str(k)];
    FRC2nd{k} = cont_po_FRC(IMInfo, RDInfo,kapa, fFull(k), omegaSpan, runidk, amplitudeFunction, true, 0.1, [fFull(k);os],[rho;0]);
end

%% Collocation for validation
newcoll = true; 
[main_collsol,isola_collsol] = coll_isola_and_main(M,C,K,fnl,fFull,lambda,fext,phiend,os,newcoll);

%% FRC plot and evaluation
% Comparison of the FRCs from SSMTool and SSMLearn with numerical integration 
% shows that SSMLearn outperforms SSMTool at this forcing level. 
[frcs,color,thm,ST] = plot_isola_and_main(BBCInfo,FRC1st,FRC2nd,[1 3]);
figure(frcs); hold on;
for k=[1 3]
    h1 = plot(main_collsol{k}.omega,main_collsol{k}.yend,'ms','DisplayName','COCO-unstable');
    om = isola_collsol{k}.omega; 
    am = isola_collsol{k}.yend; st = isola_collsol{k}.stabs;
    h2 = plot(om(st),am(st),'ro','DisplayName','COCO-stable');
    h3 = plot(om(~st),am(~st),'ms','DisplayName','COCO-unstable');
    h1.Annotation.LegendInformation.IconDisplayStyle = 'off';
    if k>1
        h2.Annotation.LegendInformation.IconDisplayStyle = 'off';
        h3.Annotation.LegendInformation.IconDisplayStyle = 'off';
    end
end
xlim(omegaSpan)
%
%% a sampled plot of periodic orbit
T    = RDInfo.transformation.map;
SSMFunction = IMInfo.parametrization.map;
phi = linspace(0,2*pi,128);
%reduced coordinate
state = FRC2nd{3}.z(143,:);
zEval = state*exp(1i*(phi));
eta   = T([zEval; conj(zEval)]); 
Zout  = SSMFunction(eta);
xz = Zout(2,:);
vz = (Zout(3,:)-Zout(1,:))/(2*dt);

omgs = FRC2nd{3}.om(143);
fs   = FRC2nd{3}.ep(143);
uICLinGuess = full(omgs^2*fs*((-omgs^2*M+K)\fext));
FForced = @(t,x,w) F(t,x) + [zeros(n,1); omgs^2*fs*(M\fext)*cos(w*t)];
opts = odeset('RelTol', 1e-4); 
[~,x_sim] = ode15s(@(t,x) FForced(t,x,omgs),[0 200*2*pi/omgs], [uICLinGuess; zeros(n,1)],opts);
[~,x_sim] = ode15s(@(t,x) FForced(t,x,omgs),[0 1*2*pi/omgs], x_sim(end,:)',opts);
figure;
plot(x_sim(:,outdof)*phiend,x_sim(:,outdof+n)*phiend,'Linewidth',1); drawnow;
hold on; plot(xz,vz); legend('simulation','SSM prediction')

%% Calibrate Force - an alternataive approach (case 2: Periodic orbits)
% In this case, the main challenge is to select a proper sampled forcing frequency 
% such that the response in steady state is periodic orbits.
% 
% Note that the system admit stable periodic orbit when $\Omega\approx\omega(\rho^\ast)$. 
% So one can also calibrate the amplitude of forcing based on the periodic responses 
% as well. This shows how to use SSM-based ROM to calibrate external forcing amplitude.
%%
embedDim = size(yData{1,2}, 1);
omgs = os;
outdof = 1:n;
ffull = [1e-3 1.5e-3 1.7e-3 2e-3];
Omega = zeros(numel(ffull),1);
for k=1:numel(ffull)
    Omega(k) = omgs;
    uICLinGuess = full(Omega(k)^2*ffull(k)*((-Omega(k)^2*M+K)\fext));
    FForced = @(t,x,w) F(t,x) + [zeros(n,1); Omega(k)^2*ffull(k)*(M\fext)*cos(w*t)];
    opts = odeset('RelTol', 1e-4); 
    [t_sim,x_sim] = ode15s(@(t,x) FForced(t,x,Omega(k)),[0 200*2*pi/Omega(k)], [uICLinGuess; zeros(n,1)],opts);
    customFigure(); plot(t_sim,x_sim(:,outdof)*phiend,'Linewidth',1); drawnow;
    [t_sim,x_sim] = ode15s(@(t,x) FForced(t,x,Omega(k)),t_sim(end)+[0 1*2*pi/Omega(k)], x_sim(end,:)',opts);
    plot(t_sim,x_sim(:,outdof)*phiend,'Linewidth',1); drawnow;
    uCal = max(abs(x_sim(:,outdof)*phiend));
    yCal(:,k) = uCal*cos(Omega(k)*dt*((1:embedDim)-ceil(0.5*embedDim))).';
end
fRedpo = calibrateFRC(IMInfo, RDInfo, yCal(:,1:numel(ffull)), Omega);
[fRedpo/os^2 fRed]
% as we can see, the difference between the two approach is significant

%% Track saddle-node bifurcation
% we use the fitted ROM to predict SN bifurcations under the variations in
% (Omega, epsilon)
bd     = coco_bd_read('postfreq_2nd3.ep');
SNlab  = coco_bd_labs(bd, 'SN'); epsfSpan = [0 1e-2];
FRCsn1 = cont_SN_FRC(IMInfo,RDInfo,epsfSpan,omegaSpan,'postfreq_2nd3',SNlab(1),'SN_post1',amplitudeFunction,true,0.2);
FRCsn2 = cont_SN_FRC(IMInfo,RDInfo,epsfSpan,omegaSpan,'postfreq_2nd3',SNlab(2),'SN_post2',amplitudeFunction,true,0.2);
% we again use the collocation method for validation
sncoll    = true;
[bd1,bd2] = coll_SN_cont(M,C,K,fnl,fFull,omegaSpan,epsfSpan,fext,os,sncoll);
% plot results at the same figure
customFigure();
plot(FRCsn1.om,FRCsn1.ep,'k-','LineWidth',2); hold on
figsn2 = plot(FRCsn2.om,FRCsn2.ep,'k-','LineWidth',2);
set(get(get(figsn2,'Annotation'),'LegendInformation'),...
                 'IconDisplayStyle','off');
ylim(epsfSpan)
omsn = coco_bd_col(bd1,'omega');
epsn = coco_bd_col(bd1, 'eps');
omsn = [omsn coco_bd_col(bd2,'omega')];
epsn = [epsn coco_bd_col(bd2, 'eps')];
plot(omsn,epsn,'bo');
xlabel('\Omega')
ylabel('\epsilon')
set(gca, 'FontSize', 14)
legend('SSM','collocation')
legend('location','NW')
legend boxoff

%% FRC at higher forcing amplitude without isola
% SSM-based prediction
runidk = ['postfreq_2nd',num2str(k)];
soleps = ep_read_solution('SN_post2.ep',11);
FRChig = cont_po_FRC(IMInfo, RDInfo,kapa, [], omegaSpan, runidk,...
    amplitudeFunction, false, 0.1, soleps.p,soleps.x);
% collocation for validation
hig_collsol = coll_high_eps(M,C,K,fnl,fext,soleps,lambda,phiend,true);
% plot results
figure; 
ax1 = gca;
FRC = FRChig;
SNidx = FRC.SNidx;
HBidx = FRC.HBidx;
FRC.st = double(FRC.st);
FRC.st(HBidx) = nan;
FRC.st(SNidx) = nan;
hold(ax1,'on');
plot_stab_lines(FRC.om,FRC.Aout(:,1),FRC.st,ST); %,legs,legu
SNfig = plot(FRC.om(SNidx),FRC.Aout(SNidx,1),thm.SN{:});
set(get(get(SNfig,'Annotation'),'LegendInformation'),...
'IconDisplayStyle','off');
HBfig = plot(FRC.om(HBidx),FRC.Aout(HBidx,1),thm.HB{:});
set(get(get(HBfig,'Annotation'),'LegendInformation'),...
'IconDisplayStyle','off');   
xlabel('$\Omega$','Interpreter','latex'); 
ylabel('$||u_1||_{\infty}$','Interpreter','latex'); 
set(gca,'FontSize',14);
grid on; axis tight; 
fighig = gcf;

figure(fighig); hold on
om = hig_collsol.omega; 
am = hig_collsol.yend;      
st = hig_collsol.stabs;
h2 = plot(om(st),am(st),'ro','DisplayName','COCO-stable');
h3 = plot(om(~st),am(~st),'ms','DisplayName','COCO-unstable');

% we observe that the ROM also predicts Hopf point, which has a good match
% with that of the full system. Following the MSSP paper, we can have a
% one-dimensional manifold of 

%% quasi-periodic orbits
% now we switch to the computation of quasi-periodic orbits
% continuation of periodic orbit of the reduced dynamics
runom = cont_po_reduced(RDInfo,kapa,fFull(3),omegaSpan,'torF3',{(13:0.2:13.6),(14.6:0.2:15.2)});
% as we can see, the system undergoes a infinite-period bifurcation when
% $\Omega\to\Omega_SN$
% we then map the obtained periodic orbits to tori in physical coordinates
labs1 = [1:14 20];
labs2 = [1:15 20]; 
FRCto_left  = quasi_po_FRC(IMInfo,RDInfo,runom{1},labs1);
FRCto_right = quasi_po_FRC(IMInfo,RDInfo,runom{2},labs2);

% numerical integration to yield FRC of quasi-periodic orbits (for
% validation)
bd_left   = coco_bd_read(runom{1});
lab_left  = coco_bd_labs(bd_left,'UZ');
bd_right  = coco_bd_read(runom{2});
lab_right = coco_bd_labs(bd_right,'UZ');
nlabs = numel(lab_left)+numel(lab_right);
soltor = cell(nlabs,1); outdof = 1:n; Ator = zeros(nlabs,1); omtor = zeros(nlabs,1);
for k=1:nlabs
    if k<=numel(lab_left)
        oms = FRCto_left.om(lab_left(k)); epf = FRCto_left.ep(lab_left(k));
    else
        gap = numel(lab_left); idx = k-gap;
        oms = FRCto_right.om(lab_right(idx)); 
        epf = FRCto_right.ep(lab_right(idx));
    end
    Ts = 2*pi/oms;
    FForced = @(t,x,w) F(t,x) + [zeros(n,1); oms^2*epf*(M\fext)*cos(w*t)];
    opts = odeset('RelTol', 1e-4); 
    [t_sim,x_sim] = ode15s(@(t,x) FForced(t,x,oms),[0 100*2*pi/oms], zeros(2*n,1),opts);
    w_sim  = x_sim(:,outdof)*phiend;
    dw_sim = x_sim(:,outdof+n)*phiend;
    figure; plot(t_sim,w_sim)
    t_p  = 0:Ts:100*Ts;
    w_p  = interp1(t_sim,w_sim,t_p);
    dw_p = interp1(t_sim,dw_sim,t_p);
    solk = struct();
    solk.om = oms;
    solk.epf = epf;
    solk.t  = t_sim; solk.x = w_sim; solk.v = dw_sim;
    solk.wp = w_p; solk.dwp = dw_p;
    soltor{k} = solk; Ator(k) = norm(w_sim,'inf'); omtor(k) = oms;
end
% we then plot the results of quasi-periodic orbits along with periodic
% orbits
figure; hold on
plot_frc_first(FRC1st{3},FRC2nd{3},main_collsol{3},isola_collsol{3})
plot(FRCto_left.om,FRCto_left.Aout,'r-','LineWidth',2,'DisplayName','SSM-quasi-po');
rig = plot(FRCto_right.om,FRCto_right.Aout,'r-','LineWidth',2);
rig.Annotation.LegendInformation.IconDisplayStyle = 'off';
plot(omtor,Ator,'kx','MarkerSize',10,'LineWidth',1.5,'DisplayName','Numerical Integration')