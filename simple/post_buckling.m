%% Finding a 2D SSM for a simply supported pipe conveying fluid: pre-buckling dynamics
% This is an example of how to reconstruct a slow 2D SSM of a mechanical system 
% using synthetic measurements of a scalar quantity. In this example, we measure 
% the midpoint displacement of a simply supported geometrically nonlinear pipe 
% conveying fluid. [1] In this livescript, we choose flowspeed=4 such that the 
% dynamics is in the supercritical region.
% 
% [1] Paidoussis, M. P. (1998). _Fluid-structure interactions: slender structures 
% and axial flow_ (Vol. 1). Academic press. 
%
% Here we take flow speed to be 4 to investigate post-buckling dynamics. In
% particular, we are interested in the dynamics of the system around one of
% the stable buckled configuration.

clearvars
close all
%% Example setup
nmodes = 4;
fcload = 1;
flowspeed = 4;
[M, C, K, fnl, fExt, fphi, phimid] = buildModel(nmodes,fcload,flowspeed,'first');
n = size(M,1);    % mechanical dofs (axial def, transverse def, angle)
[F, lambda] = functionFromTensors(M, C, K, fnl);
lambda = sort(lambda);
%% Generation of Synthetic Data
% Having set up the dynamics of the problem, we now move on to generate synthetic 
% data, which will be used to fit a parametrisation of the manifold. We will divide 
% the data into a training set, for model fitting, and a test set, for validation. 
% In this case we will use one trajectory as the training set and another one 
% as the test set.
loads = -[1 1.5];       % static load at the midpoint of the beam
nTraj = size(loads, 2);
indTest = 1;            % test data
indTrain = 2;           % train data
%% 
% We now set the initial conditions for the trajectories. Our test set trajectory 
% is initialized by applying a point load at the midpoint of the beam. The load 
% is removed at the start of the simulation. For the training trajectory, we use 
% a different point load magnitude. We expect the trajectories to eventually converge 
% onto a slow 2D manifold, which will be identified and used to reduce the system 
% dynamics.
loadvector = loads.*fExt;
IC = getStaticResponse(K, M, F, loadvector);
%% 
% The data is generated by time-integration of the right-hand side of the system. 
% In this case we are observing the midpoint displacement, so the |observable| 
% function is selected to save only the transverse displacement of the center 
% element. We also make sure that the data is sampled with a sufficiently high 
% frequency.
% 
% To save execution time and avoid rerunning the simulation, |newMeasurement| 
% can be set to |false|.

newMeasurement = true;
observable = @(x) phimid'*x(1:n,:);
slowTimeScale = 2*pi/abs(lambda(3));
% determine the shifted origin
numberPeriods = 1000; numberPointsPerPeriod = 100;
endTime = numberPeriods*slowTimeScale;
nSamp = numberPeriods*numberPointsPerPeriod+1;
xf = integrateTrajectories(F, endTime, IC(:,1), nSamp, observable);
figure;
plot(xf{1,1}, xf{1,2}, ':');   
idx = xf{1,1}>160;
xmean = mean(xf{1,2}(idx)) % midpoint deflection of the buckled configuration

numberPeriods = 300; numberPointsPerPeriod = 100;
if newMeasurement
    endTime = numberPeriods*slowTimeScale;
    nSamp = numberPeriods*numberPointsPerPeriod+1;
    dt = endTime/(nSamp-1);
    xData = integrateTrajectories(F, endTime, IC, nSamp, observable);
    DataInfo = struct('nmodes', nmodes, 'loadvector', loadvector);
    save('dataVKDecay_post.mat', 'DataInfo', 'xData', 'dt', 'endTime', 'nSamp')
else
    load dataVKDecay_post.mat
    if nmodes ~= DataInfo.nmodes
       error('The loaded data comes from a model with a different number of elements.') 
    end
end

customFigure();
plot(xData{1,1}, xData{1,2}, xData{2,1}, xData{2,2}, ':');
xlabel('$t \, [$s$]$','Interpreter','latex'); 
ylabel('$u \, [$m$]$','Interpreter','latex'); 
legend({'Trajectory 1', 'Trajectory 2'})
title('Generated data')

% shift of origin to the buckled configuration
xData{1,2} = xData{1,2}-xmean;
xData{2,2} = xData{2,2}-xmean;
%% Delay embedding
% Now we arrange the scalar measurements in an observable space of dimension 
% at least $2m+1$, with $m$ the dimension of the manifold. This guarantees that 
% the manifold from the full state space can be embedded in the observable space. 
% The dimensionality of the observable space can be further expanded with the 
% parameter |overEmbed| to facilitate recognition of the manifold from data.
% 
% We form a multi-dimensional observable by stacking $d$ subsequent scalar measurements 
% $x$ in a vector $y$, and we will later use the trajectories in this augmented 
% space for the manifold fitting.
% 
% $$\left[\begin{array}{c}y_{1} \\ \vdots \\ y_{i+1} \\ \vdots \\ y_{d+1}\end{array} 
% \right] = \left[\begin{array}{c}x(t^k) \\ \vdots \\ x(t^k+i\Delta t) \\ \vdots 
% \\ x(t^k+d\Delta t)\end{array} \right]$$
% 
% The total number of embedded coordinates is $2m+1 + \texttt{overEmbed}$.

SSMDim = 2;
overEmbed = 0;
yData = coordinatesEmbedding(xData, SSMDim, 'OverEmbedding', overEmbed);
%% Data analysis
% We need to make sure that the data that we use to identify the slow manifold 
% lies close to it. We can do this by plotting a spectrogram of the beam midpoint displacement. 
% In general, there may be many vibratory modes present at first, but the faster 
% ones quickly die out.

showSpectrogram(yData(indTrain,:), 1);
ylim([0,abs(lambda(3))/2/pi])
%% 
% We plot the midpoint displacement over time for closer inspection. 
customFigure();
plot(xData{1,1}, xData{1,2}, xData{2,1}, xData{2,2}, ':');
xlabel('$t \, [$s$]$','Interpreter','latex'); 
ylabel('$u \, [$m$]$','Interpreter','latex'); 
legend({'Trajectory 1', 'Trajectory 2'})
title('Generated data')
%% 
% Next, we use the information from the spectrogram and plot to remove the first 
% part of the training data. After the first few oscillations have passed, there 
% is one dominant mode left in the frequency spectrum. In this case, faster modes 
% die out very quickly, so we can use almost all of the data. We must however 
% remove the first transient to fulfill the assumption that trajectories lie close 
% to the SSM. We keep only the time interval |sliceInt|.

sliceInt = [5*slowTimeScale, endTime];
yDataTrunc = sliceTrajectories(yData, sliceInt);
%% Datadriven manifold fitting
SSMOrder = 1; % we fit a flat SSM here
[IMInfo, SSMChart, SSMFunction] = IMGeometry(yDataTrunc(indTrain,:), SSMDim, SSMOrder);
%% Plot and validation
% Now that we have computed the eigenspace of the manifold, we pass to the reduced 
% coordinates $y$ by projecting all trajectories onto the eigenspace:
% 
% $\eta = V_e^\top y$.

etaData = projectTrajectories(IMInfo, yData);
etaDataTrunc = projectTrajectories(IMInfo, yDataTrunc);
%% 
% We plot the test and training set trajectories projected onto the plane. After 
% all initial transients die out, the trajectories seem to be confined to a slowly 
% decaying oscillating eigenmode. This is the data we will use to train our reduced 
% order model for the dynamics. In these coordinates, the initial transient that 
% we removed is visible as irregular high-frequency oscillations in the first 
% revolution.
plotReducedCoordinates(etaData);
legend({'Test set trajectory', 'Training set trajectory'})
%% 
% Furthermore, we draw the end tip component of the manifold shape along with 
% the truncated trajectory from the training set. 

plotSSMWithTrajectories(IMInfo, 1, yDataTrunc(indTrain,:),'Margin', 60)
view(-100,20); zlabel('$u \, [$m$]$','Interpreter','latex')
%% Reduced order model
ROMOrder = 3; % we fit a order 3 extended normal form for the reduced dynamics
RDInfo = IMDynamicsFlow(etaDataTrunc(indTrain,:), ...
    'R_PolyOrd', ROMOrder, 'style', 'normalform');
%% 
[yRec, etaRec, zRec] = advect(IMInfo, RDInfo, yDataTrunc);
%% Evaluation of reduced dynamics
normedTrajDist = computeTrajectoryErrors(yRec, yDataTrunc);
NMTE = mean(normedTrajDist(indTest))
%% 
plotReducedCoordinates(etaDataTrunc(indTest,:), etaRec(indTest,:))
legend({'Test set (truncated)', 'Prediction'})
%% 
plotTrajectories(yData(indTest,:), yRec(indTest,:), 'm', 'DisplayName', {'Test set', 'Prediction'})
ylabel('$u \, [$m$]$','Interpreter','latex')
%% check eigenvalues
lambda = sort(lambda);
DSEigenvalues = lambda(1:SSMDim) % reference results
reconstructedEigenvalues = sort(RDInfo.eigenvaluesLinPartFlow) % fitted results
%% Backbone curves
% With the knowledge of the coefficients of the normal form, we extract backbone 
% curves for the instantaneous damping and frequency. In this delay-embedding 
% example, the reference physical amplitude is that of the first coordinate.

zData = transformTrajectories(RDInfo.inverseTransformation.map, etaData);
rhoCal = abs(zData{indTest(1),2}(1,1));
amplitudeFunction = @(x) x(1,:);
figure
BBCInfo = backboneCurves(IMInfo, RDInfo, amplitudeFunction, rhoCal);
subplot(121); ylabel('$u \, [$m$]$','Interpreter','latex')
subplot(122); ylabel('$u \, [$m$]$','Interpreter','latex')
%% Forced response curves
% FRC calibration
% We use our normal form dynamics to extract a forced response curve. To this 
% end, we need to define the forcing amplitude in the normal form. We do this 
% by passing to |calibrateFRC| a frequency and a point $y_\mathrm{cal}$ in the 
% observable space. At the defined frequency, the calibrated FRC will reach the 
% amplitude of this point. 
% 
% The vector $y_\mathrm{cal}$ lies in a delay embedded space, and can be computed 
% either from a delay embedded time-varying response signal, or from a scalar 
% maximal response that is artifically delay embedded. Here, |integrationBasedCalibration| 
% allows for simulation of the forced system, where $y_\mathrm{cal}$ is computed 
% from the stable response signal. Alternatively, a scalar value $u_\mathrm{cal}$ 
% can be mapped to the observable space via a cosine function oscillating at the 
% forcing frequency.

embedDim = size(yData{1,2}, 1);
fFull  = -[0.001 0.003 0.006 0.01]*0.02;
omegaSpan = abs(imag(reconstructedEigenvalues(1)))*[0.85 1.05];
outdof = 1:n;
Omega = zeros(numel(fFull),1);
sol0 = cell(numel(fFull),1);
for k=1:numel(fFull)
    Omega(k) = abs(imag(reconstructedEigenvalues(1)))*1.05; % 1.05
    loadvector = -fFull(k).*fphi;
    ICk = getStaticResponse(K, M, F, loadvector);
    FForced = @(t,x,w) F(t,x) + [zeros(n,1); Omega(k)^2*fFull(k)*(M\fphi)*cos(w*t)];
    opts = odeset('RelTol', 1e-4); 
    [t_sim,x_sim] = ode15s(@(t,x) FForced(t,x,Omega(k)),[0 300*2*pi/Omega(k)], ICk,opts);
    customFigure(); plot(t_sim,x_sim(:,outdof)*phimid,'Linewidth',1); drawnow;
    [t_sim,x_sim] = ode15s(@(t,x) FForced(t,x,Omega(k)),t_sim(end)+[0 1*2*pi/Omega(k)], x_sim(end,:)',opts);
    plot(t_sim,x_sim(:,outdof)*phimid,'Linewidth',1); drawnow;
    uCal = max(abs(x_sim(:,outdof)*phimid-xmean));
    yCal(:,k) = uCal*cos(Omega(k)*dt*((1:embedDim)-ceil(0.5*embedDim))).';
    solk = struct();
    solk.t0 = t_sim;
    solk.x0 = x_sim;
    solk.om = Omega(k);
    solk.ep = fFull(k);
    sol0{k} = solk;
end

% forcing levels in the normal form space
fRed = calibrateFRC(IMInfo, RDInfo, yCal, Omega);
fRed = fRed./Omega.^2; % due to base excitation
% we expect a proportional relation between fFull and fRed
figure; plot(fFull,fRed,'ro')
p = polyfit(fFull,fRed,1)
kapa = fRed./fFull';
kapa = kapa(3)
%% Data-driven FRC computation
% We now compute the FRC directly from the reduced dynamics model.
fFull  = -[0.001 0.003 0.006 0.01]*0.02; 
FRCs = cell(numel(fFull),1);
for k=1:numel(fFull)
    runidk = ['postfreq',num2str(k)];
    FRCs{k} = cont_po_FRC(IMInfo, RDInfo,kapa, fFull(k), omegaSpan, runidk,...
        amplitudeFunction, true, 0.1);
end

%% collocation method to validate the prediction of FRC
% we apply collocation method implemented in the po-toolbox of coco to
% extract FRC of the full system for the purpose of validation.
newcoll = true;
if newcoll
    figure;
    DS = DynamicalSystem();
    set(DS,'M',M,'C',C,'K',K,'fnl',fnl);
    set(DS.Options,'Emax',5,'Nmax',10,'notation','multiindex');
    set(DS.Options,'BaseExcitation',true);
    [V,D,W] = DS.linear_spectral_analysis();
    DS.Omega = 1.05*abs(imag(reconstructedEigenvalues(1)));
    nCycles = 10;
    outdof = 1; % first modal coordinate
    kappas = [-1; 1];
    freqRange = [0.85 1.05]*abs(imag(reconstructedEigenvalues(1)));
    for k=1:numel(fFull)
        coeffs = [fphi fphi]/2;
        DS.add_forcing(coeffs, kappas, fFull(k));
        coll = cocoWrapper(DS, nCycles, outdof);
        set(coll.Options, 'dir_name', ['post_force_',num2str(k)],...
            'h_max', 10, 'NAdapt', 5, 'PtMX', 100, 'NSV',2);        
        if k==1
        set(coll.Options,'h_max', 5, 'NAdapt', 5, 'PtMX', 100, 'NSV',2, 'al_max',15);
        end
        coll.initialGuess = 'given';
        coll.extract_FRC(freqRange,sol0{k}.t0-sol0{k}.t0(1),sol0{k}.x0,sol0{k}.om);
    end
    % post-processing: from modal coordinates to physical coordinates
    collsol = cell(numel(fFull),1);
    for k=1:numel(fFull)
        runid = ['post_force_',num2str(k),'.FRC'];
        bd = coco_bd_read(runid);
        EPlab = coco_bd_labs(bd,'EP');
        EPlab = max(EPlab);
        omegas = zeros(EPlab,1);
        ymids  = zeros(EPlab,1);
        stabs  = false(EPlab,1);
        for j=1:EPlab
            solj = po_read_solution(runid,j);
            ymid = solj.xbp(:,1:n)*phimid-xmean;
            omegas(j) = solj.p(1);
            ymids(j)  = norm(ymid,'inf');
            stabs(j)  = all(abs(solj.po_test.la)<1);
        end
        sol = struct();
        sol.omega = omegas; sol.ymid = ymids; sol.stabs = stabs;
        collsol{k} = sol;
    end
    save('dataVKcoll_post_base.mat','collsol')
else
    load('dataVKcoll_post_base.mat', 'collsol')
end


%% Plot results in the same figure (FRCs and backbone curves)
customFigure();
colors = colororder;
thm = struct();
thm.SN = {'LineStyle', 'none', 'LineWidth', 2, ...
  'Color', 'cyan', 'Marker', 'o', 'MarkerSize', 8, 'MarkerEdgeColor', ...
  'cyan', 'MarkerFaceColor', 'white'};
thm.HB = {'LineStyle', 'none', 'LineWidth', 2, ...
  'Color', 'black', 'Marker', 's', 'MarkerSize', 8, 'MarkerEdgeColor', ...
  'black', 'MarkerFaceColor', 'white'};
color = {'r','k','m','b','g'};
% color
ST = cell(2,1);
ST{1} = {'b--','LineWidth',1.5}; % unstable
ST{2} = {'b-','LineWidth',1.5};  % stable
legs = 'SSM-unstable';
legu = 'SSM-stable';
ax1 = gca;
for k=[1 2 3 4]
    FRC = FRCs{k};
    SNidx = FRC.SNidx;
    HBidx = FRC.HBidx;
    FRC.st = double(FRC.st);
    FRC.st(HBidx) = nan;
    FRC.st(SNidx) = nan;
    hold(ax1,'on');
    if k==4
        plot_stab_lines(FRC.om,FRC.Aout(:,1),FRC.st,ST,legs,legu);
    else
        plot_stab_lines(FRC.om,FRC.Aout(:,1),FRC.st,ST);
    end
    SNfig = plot(FRC.om(SNidx),FRC.Aout(SNidx,1),thm.SN{:});
    set(get(get(SNfig,'Annotation'),'LegendInformation'),...
    'IconDisplayStyle','off');
    HBfig = plot(FRC.om(HBidx),FRC.Aout(HBidx,1),thm.HB{:});
    set(get(get(HBfig,'Annotation'),'LegendInformation'),...
    'IconDisplayStyle','off');   
    xlabel('$\Omega$','Interpreter','latex'); 
    ylabel('$||u_1||_{\infty}$','Interpreter','latex'); 
    set(gca,'FontSize',14);
    grid on; axis tight; 
end

for k=[1 2 3 4]
    colk = collsol{k};
    h = plot(colk.omega(colk.stabs),colk.ymid(colk.stabs),'ro','DisplayName','COCO-stable');
    g = plot(colk.omega(~colk.stabs),colk.ymid(~colk.stabs),'ms','DisplayName','COCO-unstable');
    if k~=4
        h.Annotation.LegendInformation.IconDisplayStyle = 'off';
        if ~isempty(g)
        g.Annotation.LegendInformation.IconDisplayStyle = 'off';
        end
    end
end
plot(BBCInfo.frequency, BBCInfo.amplitude,'Color',colors(1,:),'Linewidth',2,'DisplayName', 'Backbone - SSMLearn')
xlim(omegaSpan)
xlabel('forcing frequency [rad/s]')
ylabel('displacement')
set(gca, 'FontSize', 12)
legend('location','NW')
legend boxoff


%% Track saddle-node bifurcations
% we further use the fitted ROM to predict the curve of saddle-node
% bifurcated periodic orbits in the (omega,epsilon) plane
bd    = coco_bd_read('postfreq4.ep');
SNlab = coco_bd_labs(bd, 'SN'); epsfSpan = [-2.5e-4 0];
FRCsn = cont_SN_FRC(IMInfo,RDInfo,epsfSpan,omegaSpan,'postfreq4',SNlab(1),'SN_post',amplitudeFunction,true,0.2);


%% collocation of SN points
% likewise, we use the collocation method to extract SN bifurcated periodic
% orbits for the purpose of validation
sncoll = true;
if sncoll
    DS = DynamicalSystem();
    set(DS,'M',M,'C',C,'K',K,'fnl',fnl);
    set(DS.Options,'Emax',5,'Nmax',10,'notation','multiindex');
    set(DS.Options,'BaseExcitation',true);
    [V,D,W] = DS.linear_spectral_analysis();
    DS.Omega = 0.95*abs(imag(lambda(1)));
    nCycles = 10;
    outdof = 1; % first modal coordinate
    kappas = [-1; 1];
    coeffs = [fphi fphi]/2;
    DS.add_forcing(coeffs, kappas, fFull(k));
    coll  = cocoWrapper(DS, nCycles, outdof);  
    set(coll.Options, 'dir_name', 'postFRC', 'NSV', 10);
    runid = 'post_force_4.FRC'; bdtmp = coco_bd_read(runid);
    SNlab = coco_bd_labs(bdtmp,'SN');
    bd = coll.extract_SNFRC(runid, SNlab(1), omegaSpan, epsfSpan);
end

%% We plot the results for SN at the same figure
customFigure
plot(FRCsn.om,FRCsn.ep,'k-');
xlabel('\Omega')
ylabel('\epsilon')
set(gca, 'FontSize', 12)
legend('location','NW')
legend boxoff
bd = coco_bd_read('postFRC.SNFRC');
omsn = coco_bd_col(bd,'omega');
epsn = coco_bd_col(bd, 'eps');
hold on
plot(omsn,epsn,'bo');
ylim([-2.5e-4,-1e-4])
xlim([9.3, 9.9])