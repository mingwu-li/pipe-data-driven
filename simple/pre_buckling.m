%% Finding a 2D SSM for a simply supported pipe conveying fluid: pre-buckling dynamics
% This is an example of how to reconstruct a slow 2D SSM of a mechanical system 
% using synthetic measurements of a scalar quantity. In this example, we measure 
% the midpoint displacement of a simply supported geometrically nonlinear pipe 
% conveying fluid. [1]
% 
% [1] Paidoussis, M. P. (1998). _Fluid-structure interactions: slender structures 
% and axial flow_ (Vol. 1). Academic press. 
%
% Here we take flow speed to be 1 to investigate pre-buckling dynamics

clearvars
close all
%% Example setup
nmodes = 4;
fcload = 1;
flowspeed = 1;
[M, C, K, fnl, fExt, fphi, phimid] = buildModel(nmodes,fcload,flowspeed,'first');
n = size(M,1);    % mechanical dofs (axial def, transverse def, angle)
[F, lambda] = functionFromTensors(M, C, K, fnl);
lambda = sort(lambda);
%% Generation of Synthetic Data
% Having set up the dynamics of the problem, we now move on to generate synthetic 
% data, which will be used to fit a parametrisation of the manifold. We will divide 
% the data into a training set, for model fitting, and a test set, for validation. 
% In this case we will use one trajectory as the training set and another one 
% as the test set.
loads = -[8 10]/2; % static load at the midpoint of the beam
nTraj = size(loads, 2);
indTest  = 1;      % test data
indTrain = 2;      % train data
%% 
% We now set the initial conditions for the trajectories. Our test set trajectory 
% is initialized by applying a point load at the midpoint of the beam. The load 
% is removed at the start of the simulation. For the training trajectory, we use 
% a different point load magnitude. We expect the trajectories to eventually converge 
% onto a slow 2D manifold, which will be identified and used to reduce the system 
% dynamics.
loadvector = loads.*fExt;
IC = getStaticResponse(K, M, F, loadvector);
%% 
% The data is generated by time-integration of the right-hand side of the system. 
% In this case we are observing the midpoint displacement, so the |observable| 
% function is selected to save only the transverse displacement of the center 
% element. We also make sure that the data is sampled with a sufficiently high 
% frequency.
% 
% To save execution time and avoid rerunning the simulation, |newMeasurement| 
% can be set to |false|.
newMeasurement = true;
observable = @(x) phimid'*x(1:n,:);
slowTimeScale = 2*pi/abs(lambda(1));
numberPeriods = 125; numberPointsPerPeriod = 100;
if newMeasurement
    endTime = numberPeriods*slowTimeScale;
    nSamp = numberPeriods*numberPointsPerPeriod+1;
    dt = endTime/(nSamp-1);
    xData = integrateTrajectories(F, endTime, IC, nSamp, observable);
    DataInfo = struct('nmodes', nmodes, 'loadvector', loadvector);
    save('dataVKDecay_pre.mat', 'DataInfo', 'xData', 'dt', 'endTime', 'nSamp')
else
    load dataVKDecay_pre.mat
    if nmodes ~= DataInfo.nmodes
       error('The loaded data comes from a model with a different number of elements.') 
    end
end
%% Delay embedding
% Now we arrange the scalar measurements in an observable space of dimension 
% at least $2m+1$, with $m$ the dimension of the manifold. This guarantees that 
% the manifold from the full state space can be embedded in the observable space. 
% The dimensionality of the observable space can be further expanded with the 
% parameter |overEmbed| to facilitate recognition of the manifold from data.
% 
% We form a multi-dimensional observable by stacking $d$ subsequent scalar measurements 
% $x$ in a vector $y$, and we will later use the trajectories in this augmented 
% space for the manifold fitting.
% 
% $$\left[\begin{array}{c}y_{1} \\ \vdots \\ y_{i+1} \\ \vdots \\ y_{d+1}\end{array} 
% \right] = \left[\begin{array}{c}x(t^k) \\ \vdots \\ x(t^k+i\Delta t) \\ \vdots 
% \\ x(t^k+d\Delta t)\end{array} \right]$$
% 
% The total number of embedded coordinates is $2m+1 + \texttt{overEmbed}$.

SSMDim = 2;
overEmbed = 0;
yData = coordinatesEmbedding(xData, SSMDim, 'OverEmbedding', overEmbed);
%% Data analysis
% We need to make sure that the data that we use to identify the slow manifold 
% lies close to it. We can do this by plotting a spectrogram of the beam midpoint displacement. 
% In general, there may be many vibratory modes present at first, but the faster 
% ones quickly die out.
showSpectrogram(yData(indTrain,:), 1);
ylim([0,abs(lambda(1))/2/pi*4])
%% 
% We plot the midpoint displacement over time for closer inspection. 
customFigure();
plot(xData{1,1}, xData{1,2}, xData{2,1}, xData{2,2}, ':');
xlabel('$t \, [$s$]$','Interpreter','latex'); 
ylabel('$u \, [$m$]$','Interpreter','latex'); 
legend({'Trajectory 1', 'Trajectory 2'})
title('Generated data')
%% 
% Next, we use the information from the spectrogram and plot to remove the first 
% part of the training data. After the first few oscillations have passed, there 
% is one dominant mode left in the frequency spectrum. In this case, faster modes 
% die out very quickly, so we can use almost all of the data. We must however 
% remove the first transient to fulfill the assumption that trajectories lie close 
% to the SSM. We keep only the time interval |sliceInt|.

sliceInt = [15*slowTimeScale, endTime];
yDataTrunc = sliceTrajectories(yData, sliceInt);
%% Datadriven manifold fitting
SSMOrder = 1; % we fit a flat SSM here
[IMInfo, SSMChart, SSMFunction] = IMGeometry(yDataTrunc(indTrain,:), SSMDim, SSMOrder);
%% Plot and validation
% Now that we have computed the eigenspace of the manifold, we pass to the reduced 
% coordinates $y$ by projecting all trajectories onto the eigenspace:
% 
% $\eta = V_e^\top y$.

etaData = projectTrajectories(IMInfo, yData);
etaDataTrunc = projectTrajectories(IMInfo, yDataTrunc);
%% 
% We plot the test and training set trajectories projected onto the plane. After 
% all initial transients die out, the trajectories seem to be confined to a slowly 
% decaying oscillating eigenmode. This is the data we will use to train our reduced 
% order model for the dynamics. In these coordinates, the initial transient that 
% we removed is visible as irregular high-frequency oscillations in the first 
% revolution.

plotReducedCoordinates(etaData);
legend({'Test set trajectory', 'Training set trajectory'})
%% 
% Furthermore, we draw the end tip component of the manifold shape along with 
% the truncated trajectory from the training set. 

plotSSMWithTrajectories(IMInfo, 1, yDataTrunc(indTrain,:))
view(-100,20); zlabel('$u \, [$m$]$','Interpreter','latex')
%% Reduced order model
ROMOrder = 7; % we fit a order 7 extended normal form for the reduced dynamics
RDInfo = IMDynamicsFlow(etaDataTrunc(indTrain,:), ...
    'R_PolyOrd', ROMOrder, 'style', 'normalform');
%% 
[yRec, etaRec, zRec] = advect(IMInfo, RDInfo, yDataTrunc);
%% Evaluation of reduced dynamics
normedTrajDist = computeTrajectoryErrors(yRec, yDataTrunc);
NMTE = mean(normedTrajDist(indTest)) % conjugacy error
%% 
plotReducedCoordinates(etaDataTrunc(indTest,:), etaRec(indTest,:))
legend({'Test set (truncated)', 'Prediction'})
%% 
plotTrajectories(yData(indTest,:), yRec(indTest,:), 'm', 'DisplayName', {'Test set', 'Prediction'})
ylabel('$u \, [$m$]$','Interpreter','latex')
%% check eigenvalues
lambda = sort(lambda);
DSEigenvalues = lambda(1:SSMDim) % reference results
reconstructedEigenvalues = sort(RDInfo.eigenvaluesLinPartFlow) % fitted results
%% Backbone curves
% With the knowledge of the coefficients of the normal form, we extract backbone 
% curves for the instantaneous damping and frequency. In this delay-embedding 
% example, the reference physical amplitude is that of the first coordinate.

zData = transformTrajectories(RDInfo.inverseTransformation.map, etaData);
rhoCal = abs(zData{indTest(1),2}(1,1));
amplitudeFunction = @(x) x(1,:);
figure
BBCInfo = backboneCurves(IMInfo, RDInfo, amplitudeFunction, rhoCal);
subplot(121); ylabel('$u \, [$m$]$','Interpreter','latex')
subplot(122); ylabel('$u \, [$m$]$','Interpreter','latex')
%% Forced response curves
% FRC calibration
% We use our normal form dynamics to extract a forced response curve. To this 
% end, we need to define the forcing amplitude in the normal form. We do this 
% by passing to |calibrateFRC| a frequency and a point $y_\mathrm{cal}$ in the 
% observable space. At the defined frequency, the calibrated FRC will reach the 
% amplitude of this point. 
% 
% The vector $y_\mathrm{cal}$ lies in a delay embedded space, and can be computed 
% either from a delay embedded time-varying response signal, or from a scalar 
% maximal response that is artifically delay embedded. Here, |integrationBasedCalibration| 
% allows for simulation of the forced system, where $y_\mathrm{cal}$ is computed 
% from the stable response signal. Alternatively, a scalar value $u_\mathrm{cal}$ 
% can be mapped to the observable space via a cosine function oscillating at the 
% forcing frequency.

embedDim = size(yData{1,2}, 1);
omegaSpan = abs(imag(lambda(1)))*[0.95 1.15];
outdof = 1:n;
fFull  = [3e-5 7e-5 1e-4 1.5e-4];
Omega = zeros(numel(fFull),1);
yCal  = zeros(2*SSMDim+1+overEmbed,numel(fFull));
for k=1:numel(fFull)
    Omega(k) = abs(imag(lambda(1)))*1;
    uICLinGuess = full(Omega(k)^2*fFull(k)*((-Omega(k)^2*M+K)\fphi));
    FForced = @(t,x,w) F(t,x) + [zeros(n,1); Omega(k)^2*fFull(k)*(M\fphi)*cos(w*t)];
    opts = odeset('RelTol', 1e-4); 
    [t_sim,x_sim] = ode15s(@(t,x) FForced(t,x,Omega(k)),[0 500*2*pi/Omega(k)], [uICLinGuess; zeros(n,1)],opts);
    customFigure(); plot(t_sim,x_sim(:,outdof)*phimid,'Linewidth',1); drawnow;
    [t_sim,x_sim] = ode15s(@(t,x) FForced(t,x,Omega(k)),t_sim(end)+[0 1*2*pi/Omega(k)], x_sim(end,:)',opts);
    plot(t_sim,x_sim(:,outdof)*phimid,'Linewidth',1); drawnow;
    uCal = max(abs(x_sim(:,outdof)*phimid));
    yCal(:,k) = uCal*cos(Omega(k)*dt*((1:embedDim)-ceil(0.5*embedDim))).';
end

% forcing levels in the normal form space
fRed = calibrateFRC(IMInfo, RDInfo, yCal, Omega);
fRed = fRed./Omega.^2; % due to base excitation
% we expect a proportional relation between fFull and fRed, namely, a
% linear function
figure; plot(fFull,fRed,'ro')
p = polyfit(fFull,fRed,1)
kapa = fRed./fFull';
kapa = kapa(3)
%% Data-driven FRC computation
% We now compute the FRC directly from the reduced dynamics model.
fFull  = [3e-5 1e-4 1.2e-4 1.5e-4 2e-4]; 
FRCs = cell(numel(fFull),1);
for k=1:numel(fFull)
    runidk = ['prefreq',num2str(k)];
    FRCs{k} = cont_po_FRC(IMInfo, RDInfo,kapa, fFull(k), omegaSpan, runidk, amplitudeFunction, true);
end
% FRC plot and evaluation
% Comparison of the FRCs from SSMTool and SSMLearn with numerical integration 
% shows that SSMLearn outperforms SSMTool at this forcing level. 
%% collocation method to validate the prediction of FRC
% we apply collocation method implemented in the po-toolbox of coco to
% extract FRC of the full system for the purpose of validation.
newcoll = true;
if newcoll
    figure;
    DS = DynamicalSystem();
    set(DS,'M',M,'C',C,'K',K,'fnl',fnl);
    set(DS.Options,'Emax',5,'Nmax',10,'notation','multiindex');
    set(DS.Options,'BaseExcitation',true);
    [V,D,W] = DS.linear_spectral_analysis();
    DS.Omega = 0.95*abs(imag(lambda(1)));
    nCycles = 10;
    outdof = 1; % first modal coordinate
    kappas = [-1; 1];
    %/(DS.Omega)^2;
    freqRange = [0.95 1.15]*abs(imag(lambda(1)));
    for k=1:numel(fFull)
        coeffs = [fphi fphi]/2;
        DS.add_forcing(coeffs, kappas, fFull(k));
        coll = cocoWrapper(DS, nCycles, outdof);
        set(coll.Options, 'dir_name', ['preforce_',num2str(k)],...
            'h_max', 1, 'NAdapt', 5, 'PtMX', 200, 'NSV',2);        
        if k==1
        set(coll.Options,'h_max', 1, 'NAdapt', 5, 'PtMX', 200, 'NSV',2);
        else
        end
        coll.initialGuess = 'linear';
        coll.extract_FRC(freqRange);
    end
    % post-processing: from modal coordinates to physical coordinates
    collsol = cell(numel(fFull),1);
    for k=1:numel(fFull)
        runid = ['preforce_',num2str(k),'.FRC'];
        bd = coco_bd_read(runid);
        EPlab = coco_bd_labs(bd,'EP');
        EPlab = max(EPlab);
        st = false(EPlab,1);
        omegas = zeros(EPlab,1);
        ymids  = zeros(EPlab,1);
        for j=1:EPlab
            solj = po_read_solution(runid,j);
            ymid = solj.xbp(:,1:n)*phimid;
            omegas(j) = solj.p(1);
            ymids(j)  = norm(ymid,'inf');
            st(j) = all(abs(solj.po_test.la)<1);
        end
        sol = struct();
        sol.omega = omegas; sol.ymid = ymids; sol.st = st;
        collsol{k} = sol;
    end
    save('dataVKcoll_pre_base.mat','collsol')
else
    load('dataVKcoll_pre_base.mat', 'collsol')
end


%% Plot results in the same figure (FRCs and backbone curves)
customFigure();
colors = colororder;
plot(BBCInfo.frequency, BBCInfo.amplitude,'Color',colors(1,:),'Linewidth',2,'DisplayName', 'Backbone - SSMLearn')
thm = struct();
thm.SN = {'LineStyle', 'none', 'LineWidth', 2, ...
  'Color', 'cyan', 'Marker', 'o', 'MarkerSize', 8, 'MarkerEdgeColor', ...
  'cyan', 'MarkerFaceColor', 'white'};
thm.HB = {'LineStyle', 'none', 'LineWidth', 2, ...
  'Color', 'black', 'Marker', 's', 'MarkerSize', 8, 'MarkerEdgeColor', ...
  'black', 'MarkerFaceColor', 'white'};
color = {'r','k','m','b','g'};
% color
ST = cell(2,1);
ST{1} = {'b--','LineWidth',1.5}; % unstable
ST{2} = {'b-','LineWidth',1.5};  % stable
legs = 'SSM-unstable';
legu = 'SSM-stable';
ax1 = gca;
for k=[1 2 5]
    FRC = FRCs{k};
    SNidx = FRC.SNidx;
    HBidx = FRC.HBidx;
    FRC.st = double(FRC.st);
    FRC.st(HBidx) = nan;
    FRC.st(SNidx) = nan;
    hold(ax1,'on');
    if k==2
        plot_stab_lines(FRC.om,FRC.Aout(:,1),FRC.st,ST,legs,legu);
    else
        plot_stab_lines(FRC.om,FRC.Aout(:,1),FRC.st,ST);
    end
    SNfig = plot(FRC.om(SNidx),FRC.Aout(SNidx,1),thm.SN{:});
    set(get(get(SNfig,'Annotation'),'LegendInformation'),...
    'IconDisplayStyle','off');
    HBfig = plot(FRC.om(HBidx),FRC.Aout(HBidx,1),thm.HB{:});
    set(get(get(HBfig,'Annotation'),'LegendInformation'),...
    'IconDisplayStyle','off');   
    xlabel('$\Omega$','Interpreter','latex'); 
    ylabel('$||u_1||_{\infty}$','Interpreter','latex'); 
    set(gca,'FontSize',14);
    grid on; axis tight; 
end

for k=[1 2 5]
    colk = collsol{k};
    h = plot(colk.omega(colk.st),colk.ymid(colk.st),'ro','DisplayName','COCO-stable');
    g = plot(colk.omega(~colk.st),colk.ymid(~colk.st),'ms','DisplayName','COCO-unstable');
    if k~=2
        h.Annotation.LegendInformation.IconDisplayStyle = 'off';
        if ~isempty(g)
        g.Annotation.LegendInformation.IconDisplayStyle = 'off';
        end
    end
end

xlim(omegaSpan)
xlabel('forcing frequency [rad/s]')
ylabel('displacement')
set(gca, 'FontSize', 12)
legend('location','NW')
legend boxoff

%% Track saddle-node bifurcations
% we further use the fitted ROM to predict the curve of saddle-node
% bifurcated periodic orbits in the (omega,epsilon) plane
bd    = coco_bd_read('prefreq2.ep');
SNlab = coco_bd_labs(bd, 'SN'); epsfSpan = [0 2.5e-4];
FRCsn = cont_SN_FRC(IMInfo,RDInfo,epsfSpan,omegaSpan,'prefreq2',SNlab(1),'SN_pre',amplitudeFunction,true,0.2);

%% Collocation of SN points
% likewise, we use the collocation method to extract SN bifurcated periodic
% orbits for the purpose of validation
sncoll = true;
if sncoll
    DS = DynamicalSystem();
    set(DS,'M',M,'C',C,'K',K,'fnl',fnl);
    set(DS.Options,'Emax',5,'Nmax',10,'notation','multiindex');
    set(DS.Options,'BaseExcitation',true);
    [V,D,W] = DS.linear_spectral_analysis();
    DS.Omega = 0.95*abs(imag(lambda(1)));
    nCycles = 10;
    outdof = 1; % first modal coordinate
    kappas = [-1; 1];
    freqRange = [0.95 1.15]*abs(imag(lambda(1)));
    coeffs = [fExt fExt]/2;
    DS.add_forcing(coeffs, kappas, fFull(k));
    coll  = cocoWrapper(DS, nCycles, outdof);  
    set(coll.Options, 'dir_name', 'preFRC', 'NSV', 10);
    runid = 'preforce_2.FRC'; bdtmp = coco_bd_read(runid);
    SNlab = coco_bd_labs(bdtmp,'SN');
    bd = coll.extract_SNFRC(runid, SNlab(1), omegaSpan, epsfSpan);
end
%% We plot the results for SN at the same figure
bd = coco_bd_read('preFRC.SNFRC');
customFigure
plot(FRCsn.om,FRCsn.ep,'k-');
ylim([0.3e-4 2.5e-4]);
xlabel('\Omega')
ylabel('\epsilon')
set(gca, 'FontSize', 12)
legend('location','NW')
legend boxoff
omsn = coco_bd_col(bd,'omega');
epsn = coco_bd_col(bd, 'eps');
hold on
plot(omsn,epsn,'bo');